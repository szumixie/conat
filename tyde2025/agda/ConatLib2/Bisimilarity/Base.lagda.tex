\begin{code}[hide]
{-# OPTIONS --safe --cubical --guardedness #-}
{-# OPTIONS -WnoUnsupportedIndexedMatch #-}

module ConatLib2.Bisimilarity.Base where

open import Agda.Primitive

open import Cubical.Data.Maybe
open import Cubical.Foundations.Prelude

open import Cubical.Data.Empty
  renaming (rec to exfalso)

open import ConatLib2.Type
open import ConatLib2.Inspect

private variable
  A : Set
  a₀ a₁ : A
  n k : A
\end{code}

We define a domain specific language (via \cite{danielsson-beating}) to make
the equational reasoning possible again by making the reflexivity, symmetry and
transitivity properties constructors of this language including the possibility
to use corecursive steps in a proof.

\begin{code}
data Maybe~ (A~ : A → A → Set) :
  Maybe A → Maybe A → Set
  where
    nothing-refl : Maybe~ A~ nothing nothing
    cong-just : A~ a₀ a₁ → Maybe~ A~ (just a₀) (just a₁)
\end{code}
\begin{code}[hide]
infix 4 _`≋_ _≋_
\end{code}
\begin{code}
data _≋_ (n k : ℕ∞) : Set

record _`≋_ (n k : ℕ∞) : Set where
  coinductive
\end{code}
\begin{code}[hide]
  constructor bisim
\end{code}
\begin{code}
  field
    `prove : Maybe~ _≋_ (pred n) (pred k)
\end{code}
\begin{code}[hide]
open _`≋_ public
\end{code}
\begin{code}
data _≋_ n k where
  `step  : n `≋ k → n ≋ k
  `path  : n ≡ k → n ≋ k
  `sym   : k ≋ n → n ≋ k
  `trans : ∀{m} → n ≋ m → m ≋ k → n ≋ k
\end{code}

We define the predecessor over the new \AgdaDatatype{\_≋\_} relation.
The definition itself is too long to be included here. It can be viewed
in our repository.

\begin{code}
`pred : n ≋ k → Maybe~ _≋_ (pred n) (pred k)
\end{code}
\begin{code}[hide]
`pred (`step x) = `prove x
`pred {n} {k} (`path x) with pred n | inspect pred n | pred k | inspect pred k
... | just n' | reveal eq1 | just k' | reveal eq2 = cong-just (`path (just-inj _ _ (sym eq1 ∙ cong pred x ∙ eq2)))
... | just n' | reveal eq1 | nothing | reveal eq2 = exfalso (¬just≡nothing (sym eq1 ∙ cong pred x ∙ eq2))
... | nothing | reveal eq1 | just k' | reveal eq2 = exfalso (¬nothing≡just (sym eq1 ∙ cong pred x ∙ eq2))
... | nothing | reveal eq1 | nothing | reveal eq2 = nothing-refl
`pred {n} {k} (`sym e) with pred n | pred k | `pred {k} {n} e
... | nothing  | nothing  | _ = nothing-refl
... | .just n' | .just k' | cong-just x = cong-just (`sym x)
`pred {n} {k} (`trans {m} e1 e2) with pred n | pred m | pred k | `pred {n} {m} e1 | `pred {m} {k} e2
... | nothing  | nothing  | nothing  | _  | _  = nothing-refl
... | .just n' | .just m' | .just k' | cong-just t1 | cong-just t2 = cong-just (`trans t1 t2)
\end{code}

With that we can easily show that our new language coincides with the equality over conatural numbers.

\begin{code}
run : n `≋ k → n ≡ k
runT : n ≋ k → n ≡ k
pred (runT {n} {k} x i) with {pred n} | {pred k} | `pred x
... | nothing-refl = nothing
... | cong-just t = just (runT t i)
run′ : Maybe~ _≋_ n k → n ≡ k
run′ nothing-refl = refl
run′ (cong-just x) i = just (runT x i)
pred (run e i) = run′ (`prove e) i
\end{code}

Let us set up the usual notation for equational reasoning.

\begin{code}[hide]
infixr 2 _`↺⟨_⟩_ _`↺⟨_⟨_ _`≡⟨_⟩_ _`≡⟨_⟨_ _`≋⟨_⟩_ _`≋⟨_⟨_ _`∙_ _`≡⟨⟩_
infix  3 _`∎
\end{code}
\begin{code}
pattern _`∙_  {a} a~b b~c = `trans {a} a~b b~c
pattern _`↺⟨_⟩_ a a∼b b∼c = `trans {a} (`step a∼b) b∼c
pattern _`↺⟨_⟨_ a b∼a b∼c = `trans {a} (`sym (`step b∼a)) b∼c
pattern _`≋⟨_⟩_ a a∼b b∼c = `trans {a} a∼b b∼c
pattern _`≋⟨_⟨_ a b∼a b∼c = `trans {a} (`sym b∼a) b∼c
pattern _`≡⟨_⟩_ a a∼b b∼c = `trans {a} (`path a∼b) b∼c
pattern _`≡⟨_⟨_ a b∼a b∼c = `trans {a} (`sym (`path b∼a)) b∼c

_`≡⟨⟩_ : (a : ℕ∞){b : ℕ∞} → a ≋ b → a ≋ b
a `≡⟨⟩ a∼b = `trans {a} (`path refl) a∼b
{-# INLINE _`≡⟨⟩_ #-}

_`∎ : (a : ℕ∞) → a ≋ a
a `∎ = `path {a} refl
{-# INLINE _`∎ #-}
\end{code}

Note that these last two definitions could not be made \AgdaKeyword{pattern}s
as they both use the \AgdaFunction{refl} function which is not a constructor
in Cubical Agda, just a regular function. However, if we inline their definitions,
since they are not recursive, nor corecursive, Agda sees them as guarded definitions
and it is going to accept their usage.

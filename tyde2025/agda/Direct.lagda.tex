\begin{code}[hide]
{-# OPTIONS --cubical --guardedness --no-import-sorts --no-postfix-projections --allow-unsolved-metas #-}

module Direct where

open import Cubical.Foundations.Prelude
open import Cubical.Data.Maybe using (Maybe; nothing; just)
import Cubical.Data.Nat as ℕ
open ℕ using (ℕ)
open import Introduction using (ℕ∞; pred; suc)
open import Problem using (_+_; +-match)
\end{code}
In this section, we show some examples of how to do corecursion without running
into the guardedness issue.

For multiplication, we define the operation for positive conats first

$x\times'y = (x+1)\times(y+1)-1$

we can do multiplication from scratch instead of reusing
addition. Here we define a helper function that keeps track of the original
\AgdaBound{y}.
\begin{code}[hide]
infixl 7 _×'_
mutual
\end{code}
\begin{code}
  _×'_ : ℕ∞ → ℕ∞ → ℕ∞
  x ×' y = ×'-helper x y y

  ×'-helper : ℕ∞ → ℕ∞ → ℕ∞ → ℕ∞
  pred (×'-helper x y y₀) =
    ×'-helper-match x (pred x) (pred y) y₀

  ×'-helper-match :
    ℕ∞ → Maybe ℕ∞ → Maybe ℕ∞ → ℕ∞ →
    Maybe ℕ∞
  ×'-helper-match x x' (just y') y₀ =
    just (×'-helper x y' y₀)
  ×'-helper-match x (just x') nothing y₀ =
    just (×'-helper x' y₀ y₀)
  ×'-helper-match x nothing nothing y₀ =
    nothing
\end{code}

e.g. $(3,2) \to (3,1) \to (3,0) \to (2,2) \to \dots \to (0,1) \to (0,0)$ is $4
\times 3 - 1 = 11$ steps

\begin{code}[hide]
infixl 7 _×_
mutual
\end{code}
\begin{code}
  _×_ : ℕ∞ → ℕ∞ → ℕ∞
  pred (x × y) = ×-match (pred x) (pred y)

  ×-match : Maybe ℕ∞ → Maybe ℕ∞ → Maybe ℕ∞
  ×-match nothing    y'         = nothing
  ×-match (just x')  nothing    = nothing
  ×-match (just x')  (just y')  = just (x' ×' y')
\end{code}

To prove commutativity of addition, we introduce an operation for addition of an
inductive natural number to a conatural number:
\begin{code}
infixl 6 _+L_
_+L_ : ℕ → ℕ∞ → ℕ∞
ℕ.zero +L x = x
ℕ.suc n +L x = suc (n +L x)
\end{code}

\begin{code}[hide]
mutual
\end{code}
\begin{code}
  +-comm : ∀ x y → x + y ≡ y + x
  +-comm x y = +-comm-helper₁ ℕ.zero x y refl refl

  +-comm-helper₁ :
    ∀ n x y {l r} → l ≡ x + (n +L y) → r ≡ y + (n +L x) → l ≡ r
  +-comm-helper₁ n x y le re i .pred =
    +-comm-helper₁-match n x (pred x) y (pred y)
      refl refl (cong pred le) (cong pred re) i

  +-comm-helper₁-match :
    ∀ n x x' y y' {l r} →
    pred x ≡ x' → pred y ≡ y' →
    l ≡ +-match x' (n +L y) → r ≡ +-match y' (n +L x) →
    l ≡ r
  +-comm-helper₁-match n x nothing y nothing px py le re = {!!}
  +-comm-helper₁-match n x nothing y (just y') px py le re = {!!}
  +-comm-helper₁-match n x (just x') y nothing px py le re = {!!}
  +-comm-helper₁-match n x (just x') y (just y') px py le re =
    {!!}
\end{code}

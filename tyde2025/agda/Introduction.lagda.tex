\begin{code}[hide]
{-# OPTIONS --cubical --guardedness --no-import-sorts --no-postfix-projections #-}

module Introduction where

open import Cubical.Foundations.Prelude
open import Cubical.Data.Maybe using (Maybe; nothing; just)

postulate
  ADMIT : ∀ {ℓ} {A : Type ℓ} → A
\end{code}
In dependent type theory, natural numbers are represented as an inductive type
with two constructors, one for zero and the other for the successor of a natural
number. In the Agda proof assistant, we write it as follows:
\begin{code}[hide]
module _ where private
\end{code}
\begin{code}
  data ℕ : Type where
    zero  : ℕ
    suc   : ℕ → ℕ
\end{code}
Categorically, natural numbers are the initial object in the category of
algebras over the $\mathbb{1} + {-}$ (or the ``Maybe'') endofunctor. So an
equivalent representation of natural numbers is an inductive type with a single
constructor containing a Maybe of a natural number:
\begin{code}[hide]
module _ where private
\end{code}
\begin{code}
  data ℕ : Type where
    con : Maybe ℕ → ℕ
\end{code}

We can dualize natural numbers to get \emph{conatural numbers}, which are the
terminal object in the category of coalgebras over the $\mathbb{1} + {-}$
endofunctor. In Agda, it is a coinductive record type with one destructor into
Maybe of conatural numbers:
\begin{code}
record ℕ∞ : Type where
  coinductive
  field
    pred : Maybe ℕ∞
\end{code}
\begin{code}[hide]
open ℕ∞ public

pred-inj : ∀ {x y} → pred x ≡ pred y → x ≡ y
pred (pred-inj p i) = p i
\end{code}
This destructor is the predecessor function which either fails or gives us
another conatural number.

We can define elements of \AgdaDatatype{ℕ∞} by copattern matching, that is, we
specify what the predecessor is for a particular element. As examples, zero does
not have a predecessor:
\begin{code}
zero : ℕ∞
pred zero = nothing
\end{code}
The predecessor of a successor of a number is just that number:
\begin{code}
suc : ℕ∞ → ℕ∞
pred (suc x) = just x
\end{code}
The predecessor of infinity is just infinity:
\begin{code}
∞ : ℕ∞
pred ∞ = just ∞
\end{code}
The above definition for \AgdaFunction{∞} is not structurally recursive, but it
is \emph{guarded}, that is, the recursive occurrence is after an instance of
copattern matching (\AgdaField{pred}), under only constructors
(\AgdaInductiveConstructor{just}). Agda uses guardedness to check whether a
corecursive defintion is productive. A definition is \emph{productive} when one
can compute the application of any finite amount of destructors on a corecursive
value in a finite amount of steps. Guardedness is sufficient to prove
productivity but it is not necessary, so Agda is too conservative in that
regard.

The conatural numbers can represent all natural numbers and an extra element for
infinity, however, it is not constructively isomorphic to $\mathbb{N} +
\mathbb{1}$, because all functions out of the conatural numbers must be
continuous. Computationally, finite amount output can only depend on finite
amount of input. Topologically, \AgdaFunction{∞} is the limit of $0, 1, 2,
\dots$, which must be preserved. We can visualize the topological space as
follows:
\begin{center}
  \begin{tikzpicture}[
      scale=8,
      every node/.style={
        circle,
        fill,
        inner sep=0pt,
        minimum size=1mm,
        label position=south,
        label distance=1mm,
      }
    ]
    \path
    foreach \i in {0,...,7} {($({1-(2/3)^\i},0)$) node [label=\i] {}}
    ($({1-(2/3)^7/2},0)$) node [fill=none] {\dots}
    (1,0) node [label=∞] {};
  \end{tikzpicture}
\end{center}
As a result of this restriction, we cannot define a function that decides if an
element is equal to \AgdaFunction{∞}.

For example the addition operation can be defined in Agda using guarded
corecursion.

\begin{code}[hide]
infixl 6 _+_
mutual
\end{code}
\begin{code}
  _+_ : ℕ∞ → ℕ∞ → ℕ∞
  pred (x + y) = +-step (pred x) y

  +-step : Maybe ℕ∞ → ℕ∞ → Maybe ℕ∞
  +-step nothing    y = pred y
  +-step (just x')  y = just (x' + y)
\end{code}

However, if we want to reuse the addition operation to define multiplication, we
get a non-guarded definition, which Agda rejects.

\begin{code}[hide]
infixl 7 _×_
mutual
\end{code}
\begin{code}
  {-# TERMINATING #-}
  _×_ : ℕ∞ → ℕ∞ → ℕ∞
  pred (x × y) = ×-step (pred x) y (pred y)

  ×-step :
    Maybe ℕ∞ → ℕ∞ → Maybe ℕ∞ → Maybe ℕ∞
  ×-step nothing    y y'         = nothing
  ×-step (just x')  y nothing    = nothing
  ×-step (just x')  y (just y')  = just (y' + x' × y)
\end{code}

This definition is productive but it is not guarded, since it uses the
\AgdaFunction{\_+\_}'s definition, which is not a constructor. To make Agda
accept this definition, we had to turn off the productivity checker using the
\texttt{TERMINATING} flag. However, it is not advisable to use it, because Agda
leaves us all on our own to make sure the definition terminates.

We can prove some of the usual properties of addition over conatural numbers,
like the associativity of the addition.

\begin{code}[hide]
mutual
\end{code}
\begin{code}
  +-assoc : ∀ x y z → (x + y) + z ≡ x + (y + z)
  pred (+-assoc x y z i) = +-assoc-step (pred x) y z i

  +-assoc-step :
    ∀ x' y z →
    +-step (+-step x' y) z ≡ +-step x' (y + z)
  +-assoc-step nothing    y z = refl
  +-assoc-step (just x')  y z = cong just (+-assoc x' y z)
\end{code}

This is again a nice guarded corecusion and Agda happily accepts this as a
proof. However, the proof of commutativity of addition below is rejected without
the \AgdaKeyword{TERMINATING} flag. Let us assume we have this equation
available to use in the proof of commutativity.

\begin{code}[hide]
postulate
\end{code}
\begin{code}
  +-suc : ∀ x y → x + suc y ≡ suc (x + y)
\end{code}

\begin{code}[hide]
mutual
\end{code}
\begin{code}
  {-# TERMINATING #-}
  +-comm : ∀ x y → x + y ≡ y + x
  pred (+-comm x y i) =
    +-comm-step x (pred x) y (pred y) refl refl i

  +-comm-step :
    ∀ x x' y y' → pred x ≡ x' → pred y ≡ y' →
    +-step x' y ≡ +-step y' x
  +-comm-step x (just x') y (just y') px py =
    cong just
      ( x' + y         ≡⟨ cong (x' +_) (pred-inj py) ⟩
        x' + suc y'    ≡⟨ +-suc x' y' ⟩
        suc (x' + y')  ≡⟨ cong suc (+-comm x' y') ⟩
        suc (y' + x')  ≡⟨ sym (+-suc y' x') ⟩
        y' + suc x'    ≡⟨ cong (y' +_) (pred-inj (sym px)) ⟩
        y' + x         ∎)
\end{code}
\begin{code}[hide]
  +-comm-step x nothing y nothing p q = ADMIT
  +-comm-step x nothing y (just y') p q = ADMIT
  +-comm-step x (just x') y nothing p q = ADMIT
\end{code}

Same problem again, the definition is productive but not guarded, since the
equational reasoning contains the transitivity operation which is not a
constructor.

Our contribution in this paper is to prove that the conatural numbers form an
exponential semiring by corecursion and coinduction. Along the way, we show
three different methods starting out with the formalisation, showcasing some of
the difficulties and problems. The last method we show is the one we use to
prove that the conatural numbers form an exponential semiring.

Section 2 ...

Section 3 ...

Section 4 ...

\subsection{Formalization}

For our formalisation we are going to use Cubical Agda, so the bisimulation
relation over conatural numbers coincide with equality. With that, for example,
we can define the injectivity proof for the \AgdaFunction{pred} destructor the
following way:

\subsection{Related work}

sized types

decreasing boolean sequences

Naïm

TypeTopology

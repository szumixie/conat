\begin{code}[hide]
{-# OPTIONS --cubical --guardedness --no-import-sorts --no-postfix-projections #-}

module Introduction where

open import Cubical.Foundations.Prelude
open import Cubical.Data.Maybe using (Maybe; nothing; just)

postulate
  ADMIT : ∀ {ℓ} {A : Type ℓ} → A
\end{code}

Natural numbers are the initial object in the category of algebras
over the $\mathbb{1} + {-}$ endofunctor.

In the Agda proof assistant, it can be represented as an inductive
datatype with two constructors:

\begin{code}[hide]
module _ where private
\end{code}
\begin{code}
  data ℕ : Type where
    zero  : ℕ
    suc   : ℕ → ℕ
\end{code}

Or equivalently, it is an inductive type with a single constructor
containing a Maybe of itself:

\begin{code}[hide]
module _ where private
\end{code}
\begin{code}
  data ℕ : Type where
    con : Maybe ℕ → ℕ
\end{code}

Dually, conatural numbers are the terminal object in the category of
coalgebras over the $\mathbb{1} + {-}$ endofunctor, which in Agda is a
coinductive record type with one destructor into Maybe of itself:

\begin{code}
record ℕ∞ : Type where
  coinductive
  constructor unpred
  field
    pred : Maybe ℕ∞
\end{code}
\begin{code}[hide]
open ℕ∞ public
\end{code}

We can define \AgdaFunction{zero}, \AgdaFunction{suc}, \AgdaFunction{∞} using copattern matching.

\begin{code}
zero : ℕ∞
pred zero = nothing

suc : ℕ∞ → ℕ∞
pred (suc x) = just x

∞ : ℕ∞
pred ∞ = just ∞
\end{code}

The goal of this paper is to prove that conatural numbers form an exponential semiring. Along the way we are going to show three different methods of starting out with the formalisation, showing some of the difficulties, problems. Finally, we show the last formalisation, which is the complete proof of conatural numbers being an exponential semiring.

For our formalisation we are going to use Cubical Agda, so the bisimulation relation over conatural numbers coincide with equality. With that, for example, we can define the injectivity proof for the \AgdaFunction{pred} destructor the following way:

\begin{code}
pred-inj : ∀ {x y} → pred x ≡ pred y → x ≡ y
pred (pred-inj p i) = p i
\end{code}

The conatural numbers, however, are not isomorphic to $\mathbb{1} + \mathbb{N}$. It is not the goal of the paper to prove that this fact stands. However, the following topological intuition should help to understand why this is the case:

\begin{center}
  \begin{tikzpicture}[
    scale=8,
    every node/.style={
      circle,
      fill,
      inner sep=0pt,
      minimum size=1mm,
      label position=south,
      label distance=1mm,
    }
  ]
    \path
      foreach \i in {0,...,7} {($({1-(2/3)^\i},0)$) node [label=\i] {}}
      ($({1-(2/3)^7/2},0)$) node [fill=none] {\dots}
      (1,0) node [label=∞] {};
\end{center}

Agda uses guarded corecursion to check whether a defintion is productive or not. A definition is \textit{productive} when the subsequent part of an infinite value can be computed in finitely many steps. A definition is \textit{guarded} when a corecursion happens directly in the definition or under only constructors. Guardedness is sufficient to prove productivity but it is not necessary.

For example the addition operation can be defined in Agda using guarded corecursion.

\begin{code}[hide]
infixl 6 _+_
mutual
\end{code}
\begin{code}
  _+_ : ℕ∞ → ℕ∞ → ℕ∞
  pred (x + y) = +-step (pred x) y

  +-step : Maybe ℕ∞ → ℕ∞ → Maybe ℕ∞
  +-step nothing    y = pred y
  +-step (just x')  y = just (x' + y)
\end{code}

However, if we want to reuse the addition operation to define multiplication, we get a non-guarded definition, which Agda rejects.

\begin{code}[hide]
infixl 7 _×_
mutual
\end{code}
\begin{code}
  {-# TERMINATING #-}
  _×_ : ℕ∞ → ℕ∞ → ℕ∞
  pred (x × y) = ×-step (pred x) y (pred y)

  ×-step :
    Maybe ℕ∞ → ℕ∞ → Maybe ℕ∞ → Maybe ℕ∞
  ×-step nothing    y y'         = nothing
  ×-step (just x')  y nothing    = nothing
  ×-step (just x')  y (just y')  = just (y' + x' × y)
\end{code}

This definition ------------------------ !TODO

Here the mention of the \texttt{TERMINATING} flag indicates that in its absence the definition would be rejected.

We can prove some of the usual properties of addition over conatural numbers, like the associativity of the addition.

\begin{code}[hide]
mutual
\end{code}
\begin{code}
  +-assoc : ∀ x y z → (x + y) + z ≡ x + (y + z)
  pred (+-assoc x y z i) = +-assoc-step (pred x) y z i

  +-assoc-step :
    ∀ x' y z →
    +-step (+-step x' y) z ≡ +-step x' (y + z)
  +-assoc-step nothing    y z = refl
  +-assoc-step (just x')  y z = cong just (+-assoc x' y z)
\end{code}

This is again a nice guarded corecusion and Agda happily accepts this as a proof. However, again for multiplication, this proof is rejected without the \texttt{TERMINATION} flag.

\begin{code}[hide]
postulate
\end{code}
\begin{code}
  +-suc : ∀ x y → x + suc y ≡ suc (x + y)
\end{code}

\begin{code}[hide]
mutual
\end{code}
\begin{code}
  {-# TERMINATING #-}
  +-comm : ∀ x y → x + y ≡ y + x
  pred (+-comm x y i) =
    +-comm-step x (pred x) y (pred y) refl refl i

  +-comm-step :
    ∀ x x' y y' → pred x ≡ x' → pred y ≡ y' →
    +-step x' y ≡ +-step y' x
  +-comm-step x (just x') y (just y') px py =
    cong just
      ( x' + y         ≡⟨ cong (x' +_) (pred-inj py) ⟩
        x' + suc y'    ≡⟨ +-suc x' y' ⟩
        suc (x' + y')  ≡⟨ cong suc (+-comm x' y') ⟩
        suc (y' + x')  ≡⟨ sym (+-suc y' x') ⟩
        y' + suc x'    ≡⟨ cong (y' +_) (pred-inj (sym px)) ⟩
        y' + x         ∎)
\end{code}
\begin{code}[hide]
  +-comm-step x nothing y nothing p q = ADMIT
  +-comm-step x nothing y (just y') p q = ADMIT
  +-comm-step x (just x') y nothing p q = ADMIT
\end{code}

This definition is productive but not guarded

\subsection{Related work}

sized types

decreasing boolean sequences

Naïm

TypeTopology

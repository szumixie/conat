\begin{code}[hide]
{-# OPTIONS
  --safe
  --cubical
  --guardedness
  --no-import-sorts
  --hidden-argument-puns #-}

module Quotiented where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism using (Iso; iso; isoToPath)
open import Cubical.Foundations.Univalence using (ua→)
open import Cubical.Foundations.HLevels
open import Cubical.Reflection.RecordEquiv using (declareRecordIsoΣ)
import Cubical.Data.Empty as ⊥
import Cubical.Data.Maybe as Maybe
open Maybe
  using
    ( Maybe; nothing; just;
      isOfHLevelMaybe; just-inj; ¬nothing≡just; ¬just≡nothing)

module E where
\end{code}
Adapting the approach in Section~\ref{sec:dsl}

First show that conatural numbers form a commutative semiring

We mutually define expressions and head normal expressions
\begin{code}
  record NExpr : Type
  data Expr : Type
\end{code}
head normal expressions are a coinductive record where we can extract the
predecessor
\begin{code}
  record NExpr where
    coinductive
    field pred : Maybe Expr
\end{code}
\begin{code}[hide]
  open NExpr public

  infixl 6 _+_
  infixl 7 _*_
\end{code}
In \AgdaDatatype{Expr}, we include all of the commutative semiring equations
\begin{code}
  data Expr where
    isSetExpr : isSet Expr

    _+_ : Expr → Expr → Expr
    +-assoc : ∀ x y z → (x + y) + z ≡ x + (y + z)
    +-comm : ∀ x y → x + y ≡ y + x

    zero : Expr
    +-idₗ : ∀ x → zero + x ≡ x

    _*_ : Expr → Expr → Expr
    *-assoc : ∀ x y z → (x * y) * z ≡ x * (y * z)
    *-comm : ∀ x y → x * y ≡ y * x

    one : Expr
    *-idₗ : ∀ x → one * x ≡ x

    *-distₗ-+ : ∀ x y z → (x + y) * z ≡ x * z + y * z
    *-annihₗ : ∀ x → zero * x ≡ zero
\end{code}
We add a constructor to embed head normal expressions into expressions, this way
we can construct infinite expressions, as long as they are guarded
\begin{code}
    embed : NExpr → Expr
\end{code}
We add equations to relate taking the predecessor on the head normal expression

Note that we use the destructor \AgdaField{pred} of \AgdaRecord{NExpr}
\begin{code}
    embed-zero : ∀ x → pred x ≡ nothing → embed x ≡ zero
    embed-suc : ∀ x x-1 → pred x ≡ just x-1 → embed x ≡ one + x-1
\end{code}
Finally, a constructor for transitivity because the general transitivity
function does not preserve guardedness
\begin{code}
    trans : ∀ {x y z} → x ≡ y → y ≡ z → x ≡ z
\end{code}
\begin{code}[hide]
  suc : Expr → Expr
  suc x = one + x

  module ConatReasoning where
    infixl 6 _⟩+⟨_
    _⟩+⟨_ : ∀ {x x' y y'} → x ≡ x' → y ≡ y' → x + y ≡ x' + y'
    p ⟩+⟨ q = cong₂ _+_ p q

    +-idᵣ : ∀ x → x + zero ≡ x
    +-idᵣ x =
      x + zero ≡⟨ +-comm _ _ ⟩
      zero + x ≡⟨ +-idₗ _ ⟩
      x        ∎

    module _ {a x y z} (p : x + y ≡ z) where
      +-pullᵣ : a + x + y ≡ a + z
      +-pullᵣ =
        a + x + y   ≡⟨ +-assoc _ _ _ ⟩
        a + (x + y) ≡⟨ refl ⟩+⟨ p ⟩
        a + z       ∎

    module _ {a x y z} (p : x ≡ y + z) where
      +-pushᵣ : a + x ≡ a + y + z
      +-pushᵣ = sym (+-pullᵣ (sym p))

    module _ {a x} (p : zero ≡ x) where
      +-introₗ : a ≡ x + a
      +-introₗ =
        a        ≡⟨ sym (+-idₗ _) ⟩
        zero + a ≡⟨ p ⟩+⟨ refl ⟩
        x + a    ∎

      +-introᵣ : a ≡ a + x
      +-introᵣ =
        a        ≡⟨ sym (+-idᵣ _) ⟩
        a + zero ≡⟨ refl ⟩+⟨ p ⟩
        a + x    ∎

    module _ {a x} (p : x ≡ zero) where
      +-elimₗ : x + a ≡ a
      +-elimₗ = sym (+-introₗ (sym p))

      +-elimᵣ : a + x ≡ a
      +-elimᵣ = sym (+-introᵣ (sym p))

    module _ {a x y z w} (p : x + y ≡ z + w) where
      +-extendᵣ : a + x + y ≡ a + z + w
      +-extendᵣ =
        a + x + y   ≡⟨ +-assoc _ _ _ ⟩
        a + (x + y) ≡⟨ refl ⟩+⟨ p ⟩
        a + (z + w) ≡⟨ sym (+-assoc _ _ _) ⟩
        a + z + w   ∎

    +-sucₗ : ∀ x y → suc x + y ≡ suc (x + y)
    +-sucₗ x y = +-assoc _ _ _

    +-sucᵣ : ∀ x y → x + suc y ≡ suc (x + y)
    +-sucᵣ x y =
      x + suc y   ≡⟨ +-comm _ _ ⟩
      suc y + x   ≡⟨ +-sucₗ _ _ ⟩
      suc (y + x) ≡⟨ cong suc (+-comm _ _) ⟩
      suc (x + y) ∎

    infixl 7 _⟩*⟨_
    _⟩*⟨_ : ∀ {x x' y y'} → x ≡ x' → y ≡ y' → x * y ≡ x' * y'
    p ⟩*⟨ q = cong₂ _*_ p q

    *-idᵣ : ∀ x → x * one ≡ x
    *-idᵣ x =
      x * one ≡⟨ *-comm _ _ ⟩
      one * x ≡⟨ *-idₗ _ ⟩
      x       ∎

    module _ {a x y z} (p : x * y ≡ z) where
      *-pullᵣ : a * x * y ≡ a * z
      *-pullᵣ =
        a * x * y   ≡⟨ *-assoc _ _ _ ⟩
        a * (x * y) ≡⟨ refl ⟩*⟨ p ⟩
        a * z       ∎

    module _ {a x y z} (p : x ≡ y * z) where
      *-pushᵣ : a * x ≡ a * y * z
      *-pushᵣ = sym (*-pullᵣ (sym p))

    module _ {a x} (p : one ≡ x) where
      *-introᵣ : a ≡ a * x
      *-introᵣ =
        a       ≡⟨ sym (*-idᵣ _) ⟩
        a * one ≡⟨ refl ⟩*⟨ p ⟩
        a * x   ∎

    module _ {a x} (p : x ≡ one) where
      *-elimᵣ : a * x ≡ a
      *-elimᵣ = sym (*-introᵣ (sym p))

    module _ {a x y z w} (p : x * y ≡ z * w) where
      *-extendᵣ : a * x * y ≡ a * z * w
      *-extendᵣ =
        a * x * y   ≡⟨ *-assoc _ _ _ ⟩
        a * (x * y) ≡⟨ refl ⟩*⟨ p ⟩
        a * (z * w) ≡⟨ sym (*-assoc _ _ _) ⟩
        a * z * w   ∎

    *-annihᵣ : ∀ x → x * zero ≡ zero
    *-annihᵣ x =
      x * zero ≡⟨ *-comm _ _ ⟩
      zero * x ≡⟨ *-annihₗ _ ⟩
      zero     ∎

    *-sucₗ : ∀ x y → suc x * y ≡ y + x * y
    *-sucₗ x y =
      (one + x) * y   ≡⟨ *-distₗ-+ _ _ _ ⟩
      one * y + x * y ≡⟨ *-idₗ _ ⟩+⟨ refl ⟩
      y + x * y       ∎

    *-sucᵣ : ∀ x y → x * suc y ≡ x + x * y
    *-sucᵣ x y =
      x * suc y ≡⟨ *-comm _ _ ⟩
      suc y * x ≡⟨ *-sucₗ _ _ ⟩
      x + y * x ≡⟨ refl ⟩+⟨ *-comm _ _ ⟩
      x + x * y ∎

    one-suc : one ≡ suc zero
    one-suc = sym (+-idᵣ _)

    unpred : Maybe Expr → Expr
    unpred nothing = zero
    unpred (just x-1) = suc x-1

  open ConatReasoning

  data IsPred : Maybe Expr → Expr → Type where
    nothing : IsPred nothing zero
    just : ∀ x-1 → IsPred (just x-1) (suc x-1)

  isPropIsPred-zero :
    ∀ {x-1 x} (p : nothing ≡ x-1) (q : zero ≡ x) r →
    PathP (λ i → IsPred (p i) (q i)) nothing r
  isPropIsPred-zero p q nothing =
    subst2 (λ e₁ e₂ → PathP (λ i → IsPred (e₁ i) (e₂ i)) nothing nothing)
      (isOfHLevelMaybe 0 isSetExpr _ _ refl p)
      (isSetExpr _ _ refl q)
      refl
  isPropIsPred-zero p q (just x-1) = ⊥.rec (¬nothing≡just p)

  isPropIsPred-suc :
    ∀ {x-1 x} x-1′ (p : just x-1′ ≡ x-1) (q : suc x-1′ ≡ x) r →
    PathP (λ i → IsPred (p i) (q i)) (just x-1′) r
  isPropIsPred-suc x-1′ p q nothing = ⊥.rec (¬just≡nothing p)
  isPropIsPred-suc x-1′ p q (just x-1) =
    subst2 (λ e₁ e₂ → PathP (λ i → IsPred (e₁ i) (e₂ i)) (just x-1′) (just x-1))
      (isOfHLevelMaybe 0 isSetExpr _ _ (cong just (just-inj _ _ p)) p)
      (isSetExpr _ _ (cong suc (just-inj _ _ p)) q)
      (cong IsPred.just (just-inj _ _ p))

  isPropIsPred : ∀ x-1 x → isProp (IsPred x-1 x)
  isPropIsPred _ _ nothing q = isPropIsPred-zero refl refl q
  isPropIsPred _ _ (just x-1) q = isPropIsPred-suc x-1 refl refl q
\end{code}
We want to define the predecessor function on expressions by induction

We define the motive
\begin{code}
  record Pred (x : Expr) : Type where
    field
      pred : Maybe Expr
      isPred : IsPred pred x
\end{code}
\begin{code}[hide]
  open Pred
  unquoteDecl PredIsoΣ = declareRecordIsoΣ PredIsoΣ (quote Pred)

  Pred-path :
    ∀ {x y} {p : x ≡ y} {xᴾ yᴾ} →
    xᴾ .pred ≡ yᴾ .pred → PathP (λ i → Pred (p i)) xᴾ yᴾ
  Pred-path q i .pred = q i
  Pred-path {p} {xᴾ} {yᴾ} q i .isPred =
    isProp→PathP (λ i → isPropIsPred (q i) (p i)) (xᴾ .isPred) (yᴾ .isPred) i
\end{code}
We need this to eliminate

We can prove that it is a set using library stuff
\begin{code}
  isSetPred : ∀ x → isSet (Pred x)
  isSetPred x =
    isOfHLevelRetractFromIso 2 PredIsoΣ
      (isSetΣ (isOfHLevelMaybe 0 isSetExpr) λ x-1 →
        isProp→isSet (isPropIsPred _ _))
\end{code}
\begin{code}
  +-pred : Maybe Expr → Expr → Maybe Expr → Maybe Expr
  +-pred nothing y y-1 = y-1
  +-pred (just x-1) y y-1 = just (x-1 + y)

  +-isPred :
    ∀ {x x-1 y y-1} →
    IsPred x-1 x → IsPred y-1 y → IsPred (+-pred x-1 y y-1) (x + y)
  +-isPred {y} nothing p = subst (IsPred _) (sym (+-idₗ _)) p
  +-isPred {y} (just x-1) p =
    subst (IsPred _) (sym (+-sucₗ _ _)) (just (x-1 + y))

  infixl 6 _+ᴾ_
  _+ᴾ_ : ∀ {x y} → Pred x → Pred y → Pred (x + y)
  _+ᴾ_ {y} xᴾ yᴾ .pred = +-pred (xᴾ .pred) y (yᴾ .pred)
  (xᴾ +ᴾ yᴾ) .isPred = +-isPred (xᴾ .isPred) (yᴾ .isPred)
\end{code}
\begin{code}[hide]
  +-assoc-pred :
    ∀ x-1 y y-1 z z-1 →
    +-pred (+-pred x-1 y y-1) z z-1 ≡ +-pred x-1 (y + z) (+-pred y-1 z z-1)
  +-assoc-pred nothing y y-1 z z-1 = refl
  +-assoc-pred (just x-1) y y-1 z z-1 = congS just (+-assoc _ _ _)

  +-assocᴾ :
    ∀ {x y z} xᴾ yᴾ zᴾ →
    PathP (λ i → Pred (+-assoc x y z i)) ((xᴾ +ᴾ yᴾ) +ᴾ zᴾ) (xᴾ +ᴾ (yᴾ +ᴾ zᴾ))
  +-assocᴾ {y} {z} xᴾ yᴾ zᴾ =
    Pred-path (+-assoc-pred (xᴾ .pred) y (yᴾ .pred) z (zᴾ .pred))
\end{code}
\begin{code}
  +-comm-pred :
    ∀ {x x-1 y y-1} → IsPred x-1 x → IsPred y-1 y →
    +-pred x-1 y y-1 ≡ +-pred y-1 x x-1
  +-comm-pred nothing nothing = refl
  +-comm-pred nothing (just y-1) = congS just (sym (+-idᵣ _))
  +-comm-pred (just x-1) nothing = congS just (+-idᵣ _)
  +-comm-pred (just x-1) (just y-1) =
    congS just
      ( x-1 + suc y-1   ≡⟨ +-sucᵣ _ _ ⟩
        suc (x-1 + y-1) ≡⟨ cong suc (+-comm _ _) ⟩
        suc (y-1 + x-1) ≡⟨ sym (+-sucᵣ _ _) ⟩
        y-1 + suc x-1   ∎)
\end{code}
\begin{code}[hide]
  +-commᴾ :
    ∀ {x y} xᴾ yᴾ → PathP (λ i → Pred (+-comm x y i)) (xᴾ +ᴾ yᴾ) (yᴾ +ᴾ xᴾ)
  +-commᴾ xᴾ yᴾ = Pred-path (+-comm-pred (xᴾ .isPred) (yᴾ .isPred))

  zeroᴾ : Pred zero
  zeroᴾ .pred = nothing
  zeroᴾ .isPred = nothing

  +-idₗᴾ : ∀ {x} xᴾ → PathP (λ i → Pred (+-idₗ x i)) (zeroᴾ +ᴾ xᴾ) xᴾ
  +-idₗᴾ xᴾ = Pred-path refl

  *-pred : Maybe Expr → Expr → Maybe Expr → Maybe Expr
  *-pred nothing y y-1 = nothing
  *-pred (just x-1) y nothing = nothing
  *-pred (just x-1) y (just y-1) = just (y-1 + x-1 * y)

  *-isPred :
    ∀ {x x-1 y y-1} →
    IsPred x-1 x → IsPred y-1 y → IsPred (*-pred x-1 y y-1) (x * y)
  *-isPred nothing p = subst (IsPred _) (sym (*-annihₗ _)) nothing
  *-isPred (just x-1) nothing = subst (IsPred _) (sym (*-annihᵣ _)) nothing
  *-isPred {y} (just x-1) (just y-1) =
    subst (IsPred _)
      ( suc (y-1 + x-1 * y) ≡⟨ sym (+-sucₗ _ _) ⟩
        suc y-1 + x-1 * y   ≡⟨⟩
        y + x-1 * y         ≡⟨ sym (*-sucₗ _ _) ⟩
        suc x-1 * y         ∎)
      (just (y-1 + x-1 * y))

  infixl 7 _*ᴾ_
  _*ᴾ_ : ∀ {x y} → Pred x → Pred y → Pred (x * y)
  _*ᴾ_ {y} xᴾ yᴾ .pred = *-pred (xᴾ .pred) y (yᴾ .pred)
  (xᴾ *ᴾ yᴾ) .isPred = *-isPred (xᴾ .isPred) (yᴾ .isPred)

  *-assoc-pred :
    ∀ x-1 y y-1 z z-1 →
    *-pred (*-pred x-1 y y-1) z z-1 ≡ *-pred x-1 (y * z) (*-pred y-1 z z-1)
  *-assoc-pred nothing y y-1 z z-1 = refl
  *-assoc-pred (just x-1) y nothing z z-1 = refl
  *-assoc-pred (just x-1) y (just y-1) z nothing = refl
  *-assoc-pred (just x-1) y (just y-1) z (just z-1) =
    congS just
      ( z-1 + (y-1 + x-1 * y) * z     ≡⟨ +-pushᵣ (*-distₗ-+ _ _ _) ⟩
        z-1 + y-1 * z + x-1 * y * z   ≡⟨ refl ⟩+⟨ *-assoc _ _ _ ⟩
        z-1 + y-1 * z + x-1 * (y * z) ∎)

  *-assocᴾ : ∀ {x y z} xᴾ yᴾ zᴾ →
    PathP (λ i → Pred (*-assoc x y z i)) ((xᴾ *ᴾ yᴾ) *ᴾ zᴾ) (xᴾ *ᴾ (yᴾ *ᴾ zᴾ))
  *-assocᴾ {x} {y} {z} xᴾ yᴾ zᴾ =
    Pred-path (*-assoc-pred (xᴾ .pred) y (yᴾ .pred) z (zᴾ .pred))

  *-comm-pred :
    ∀ {x x-1 y y-1} → IsPred x-1 x → IsPred y-1 y →
    *-pred x-1 y y-1 ≡ *-pred y-1 x x-1
  *-comm-pred nothing nothing = refl
  *-comm-pred nothing (just y-1) = refl
  *-comm-pred (just x-1) nothing = refl
  *-comm-pred (just x-1) (just y-1) =
    congS just
      ( y-1 + x-1 * suc y-1   ≡⟨ +-pushᵣ (*-sucᵣ _ _) ⟩
        y-1 + x-1 + x-1 * y-1 ≡⟨ +-comm _ _ ⟩+⟨ *-comm _ _ ⟩
        x-1 + y-1 + y-1 * x-1 ≡⟨ +-pullᵣ (sym (*-sucᵣ _ _)) ⟩
        x-1 + y-1 * suc x-1 ∎)

  *-commᴾ :
    ∀ {x y} xᴾ yᴾ → PathP (λ i → Pred (*-comm x y i)) (xᴾ *ᴾ yᴾ) (yᴾ *ᴾ xᴾ)
  *-commᴾ xᴾ yᴾ = Pred-path (*-comm-pred (xᴾ .isPred) (yᴾ .isPred))

  oneᴾ : Pred one
  oneᴾ .pred = just zero
  oneᴾ .isPred = subst (IsPred _) (sym one-suc) (just zero)

  *-idₗ-pred : ∀ x x-1 → *-pred (just zero) x x-1 ≡ x-1
  *-idₗ-pred x nothing = refl
  *-idₗ-pred x (just x-1) = congS just (+-elimᵣ (*-annihₗ _))

  *-idₗᴾ : ∀ {x} xᴾ → PathP (λ i → Pred (*-idₗ x i)) (oneᴾ *ᴾ xᴾ) xᴾ
  *-idₗᴾ {x} xᴾ = Pred-path (*-idₗ-pred x (xᴾ .pred))

  *-distₗ-+-pred :
    ∀ x-1 y y-1 z z-1 →
    *-pred (+-pred x-1 y y-1) z z-1 ≡
    +-pred (*-pred x-1 z z-1) (y * z) (*-pred y-1 z z-1)
  *-distₗ-+-pred nothing y y-1 z z-1 = refl
  *-distₗ-+-pred (just x) y y-1 z (just z-1) =
    congS just (+-pushᵣ (*-distₗ-+ _ _ _))
  *-distₗ-+-pred (just x) y nothing z nothing = refl
  *-distₗ-+-pred (just x) y (just y-1) z nothing = refl

  *-distₗ-+ᴾ :
    ∀ {x y z} xᴾ yᴾ zᴾ →
    PathP (λ i → Pred (*-distₗ-+ x y z i))
      ((xᴾ +ᴾ yᴾ) *ᴾ zᴾ) (xᴾ *ᴾ zᴾ +ᴾ yᴾ *ᴾ zᴾ)
  *-distₗ-+ᴾ {y} {z} xᴾ yᴾ zᴾ =
    Pred-path (*-distₗ-+-pred (xᴾ .pred) y (yᴾ .pred) z (zᴾ .pred))

  *-annihₗᴾ : ∀ {x} xᴾ → PathP (λ i → Pred (*-annihₗ x i)) (zeroᴾ *ᴾ xᴾ) zeroᴾ
  *-annihₗᴾ xᴾ = Pred-path refl

  sucᴾ : ∀ {x} → Pred x → Pred (suc x)
  sucᴾ = oneᴾ +ᴾ_

  transᴾ :
    ∀ {x y z} {p : x ≡ y} {q : y ≡ z} {xᴾ yᴾ zᴾ} →
    PathP (λ i → Pred (p i)) xᴾ yᴾ → PathP (λ i → Pred (q i)) yᴾ zᴾ →
    PathP (λ i → Pred (trans p q i)) xᴾ zᴾ
  transᴾ pᴾ qᴾ = Pred-path ((λ i → pᴾ i .pred) ∙ (λ i → qᴾ i .pred))

  embed-isPred : ∀ x x-1 → x .pred ≡ x-1 → IsPred x-1 (embed x)
  embed-isPred x nothing p = subst (IsPred _) (sym (embed-zero x p)) nothing
  embed-isPred x (just x-1) p =
    subst (IsPred _) (sym (embed-suc x x-1 p)) (just x-1)

  embedᴾ : ∀ x → Pred (embed x)
  embedᴾ x .pred = x .pred
  embedᴾ x .isPred = embed-isPred x (x .pred) refl

  embed-zeroᴾ : ∀ x p → PathP (λ i → Pred (embed-zero x p i)) (embedᴾ x) zeroᴾ
  embed-zeroᴾ x p = Pred-path p

  embed-sucᴾ :
    ∀ {x-1} x x-1ᴾ p →
    PathP (λ i → Pred (embed-suc x x-1 p i)) (embedᴾ x) (sucᴾ x-1ᴾ)
  embed-sucᴾ {x-1} x x-1ᴾ p = Pred-path
    ( x .pred           ≡⟨ p ⟩
      just x-1          ≡⟨ congS just (sym (+-idₗ _)) ⟩
      just (zero + x-1) ∎)
\end{code}
\begin{code}
  ⟦_⟧ᴾ : ∀ x → Pred x
\end{code}
\begin{code}[hide]
  ⟦ isSetExpr x y p q i j ⟧ᴾ =
    isOfHLevel→isOfHLevelDep 2 (λ x → isSetPred x)
      ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ (cong ⟦_⟧ᴾ p) (cong ⟦_⟧ᴾ q) (isSetExpr _ _ _ _) i j

  ⟦ x + y ⟧ᴾ = ⟦ x ⟧ᴾ +ᴾ ⟦ y ⟧ᴾ
  ⟦ +-assoc x y z i ⟧ᴾ = +-assocᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ ⟦ z ⟧ᴾ i
  ⟦ +-comm x y i ⟧ᴾ = +-commᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ i
  ⟦ zero ⟧ᴾ = zeroᴾ
  ⟦ +-idₗ x i ⟧ᴾ = +-idₗᴾ ⟦ x ⟧ᴾ i

  ⟦ x * y ⟧ᴾ = ⟦ x ⟧ᴾ *ᴾ ⟦ y ⟧ᴾ
  ⟦ *-assoc x y z i ⟧ᴾ = *-assocᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ ⟦ z ⟧ᴾ i
  ⟦ *-comm x y i ⟧ᴾ = *-commᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ i
  ⟦ one ⟧ᴾ = oneᴾ
  ⟦ *-idₗ x i ⟧ᴾ = *-idₗᴾ ⟦ x ⟧ᴾ i
  ⟦ *-distₗ-+ x y z i ⟧ᴾ = *-distₗ-+ᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ ⟦ z ⟧ᴾ i
  ⟦ *-annihₗ x i ⟧ᴾ = *-annihₗᴾ ⟦ x ⟧ᴾ i

  ⟦ trans p q i ⟧ᴾ = transᴾ (cong ⟦_⟧ᴾ p) (cong ⟦_⟧ᴾ q) i
  ⟦ embed x ⟧ᴾ = embedᴾ x
  ⟦ embed-zero x p i ⟧ᴾ = embed-zeroᴾ x p i
  ⟦ embed-suc x x-1 p i ⟧ᴾ = embed-sucᴾ x ⟦ x-1 ⟧ᴾ p i
\end{code}
\begin{code}
  predᴱ : Expr → Maybe Expr
  predᴱ x = ⟦ x ⟧ᴾ .pred

  isPredᴱ : ∀ x → IsPred (predᴱ x) x
  isPredᴱ x = ⟦ x ⟧ᴾ .isPred
\end{code}
\begin{code}[hide]
  pred-zero : predᴱ zero ≡ nothing
  pred-zero = refl

  pred-suc : ∀ x → predᴱ (suc x) ≡ just x
  pred-suc x = congS just (+-idₗ _)

  unpred-pred-pred : ∀ {x x-1} → IsPred x-1 x → Maybe.rec zero suc x-1 ≡ x
  unpred-pred-pred nothing = refl
  unpred-pred-pred (just x-1) = refl

  unpred-pred : ∀ x → Maybe.rec zero suc (predᴱ x) ≡ x
  unpred-pred x = unpred-pred-pred (isPredᴱ x)

  interp : Expr → NExpr
  interp x .pred = predᴱ x

  interp-embed : ∀ x → interp (embed x) ≡ x
  interp-embed x i .pred = x .pred

  embed-interp : ∀ x → embed (interp x) ≡ x
  embed-interp-pred : ∀ {x x-1} → IsPred x-1 x → embed (interp x) ≡ x

  embed-interp x = embed-interp-pred (isPredᴱ x)
  embed-interp-pred nothing = embed-zero (interp zero) refl
  embed-interp-pred (just x-1) =
    embed-suc (interp (suc x-1)) x-1 (congS just (+-idₗ _))

  ExprIsoNExpr : Iso Expr NExpr
  ExprIsoNExpr = iso interp embed interp-embed embed-interp

open E using (NExpr; Expr; pred; predᴱ)

record Conat : Type where
  coinductive
  field pred : Maybe Conat

open Conat public

embed : Conat → Expr
embedᴺ : Conat → NExpr
embed-pred : Maybe Conat → Maybe Expr

embed x = E.embed (embedᴺ x)
embedᴺ x .pred = embed-pred (x .pred)
embed-pred nothing = nothing
embed-pred (just x-1) = just (embed x-1)

interp : Expr → Conat
interp-pred : Maybe Expr → Maybe Conat

interp x .pred = interp-pred (predᴱ x)
interp-pred nothing = nothing
interp-pred (just x-1) = just (interp x-1)

interp-embed : ∀ x → interp (embed x) ≡ x
interp-embed-pred : ∀ x-1 → interp-pred (embed-pred x-1) ≡ x-1

interp-embed x i .pred = interp-embed-pred (x .pred) i
interp-embed-pred nothing = refl
interp-embed-pred (just x-1) = cong just (interp-embed x-1)

embed-interp : ∀ x → embed (interp x) ≡ x
embed-interpᴺ : ∀ x → embedᴺ (interp x) ≡ E.interp x
embed-interp-pred : ∀ x-1 → embed-pred (interp-pred x-1) ≡ x-1

embed-interp x = E.trans (cong E.embed (embed-interpᴺ x)) (E.embed-interp x)
embed-interpᴺ x i .pred = embed-interp-pred (predᴱ x) i
embed-interp-pred nothing = refl
embed-interp-pred (just x-1) = cong just (embed-interp x-1)

ExprIsoConat : Iso Expr Conat
ExprIsoConat = iso interp embed interp-embed embed-interp
\end{code}
\begin{code}
record ConatStr (A : Type) (pred : A → Maybe A) : Type
\end{code}
\begin{code}[hide]
record ConatStr A pred where
  infixl 6 _+_
  infixl 7 _*_
  field
    isSetA : isSet A

    _+_ : A → A → A
    +-assoc : ∀ x y z → (x + y) + z ≡ x + (y + z)
    +-comm : ∀ x y → x + y ≡ y + x

    zero : A
    +-idₗ : ∀ x → zero + x ≡ x

    _*_ : A → A → A
    *-assoc : ∀ x y z → (x * y) * z ≡ x * (y * z)
    *-comm : ∀ x y → x * y ≡ y * x

    one : A
    *-idₗ : ∀ x → one * x ≡ x

    *-distₗ-+ : ∀ x y z → (x + y) * z ≡ x * z + y * z
    *-annihₗ : ∀ x → zero * x ≡ zero

  suc : A → A
  suc = one +_
\end{code}
\begin{code}
  field
    pred-zero : pred zero ≡ nothing
    pred-suc : ∀ x → pred (suc x) ≡ just x
    unpred-pred : ∀ x → Maybe.rec zero suc (pred x) ≡ x

conatStrExpr : ConatStr Expr predᴱ
\end{code}
\begin{code}[hide]
conatStrExpr =
  record
    { isSetA = E.isSetExpr;
      Expr;
      pred-zero = E.pred-zero;
      pred-suc = E.pred-suc;
      unpred-pred = E.unpred-pred }
\end{code}
\begin{code}
conatStrPredConat : ConatStr Conat pred
conatStrPredConat =
  transport
    (cong₂ ConatStr
      (isoToPath ExprIsoConat)
      (ua→ λ x → toPathP (subst-Maybe _)))
    conatStrExpr
\end{code}
\begin{code}[hide]
  where
  subst-Maybe :
    ∀ x-1 → subst Maybe (isoToPath ExprIsoConat) x-1 ≡ interp-pred x-1
  subst-Maybe nothing = refl
  subst-Maybe (just x-1) = cong just (transportRefl _)

open ConatStr conatStrPredConat renaming (isSetA to isSetConat) public
\end{code}

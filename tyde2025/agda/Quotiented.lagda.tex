\begin{code}[hide]
{-# OPTIONS
  --safe
  --cubical
  --guardedness
  --no-import-sorts
  --hidden-argument-puns #-}

module Quotiented where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism using (Iso; iso; isoToPath)
open import Cubical.Foundations.Univalence using (ua→)
open import Cubical.Foundations.HLevels
open import Cubical.Reflection.RecordEquiv using (declareRecordIsoΣ)
import Cubical.Data.Empty as ⊥
open import Cubical.Data.Maybe
  using
    ( Maybe; nothing; just;
      isOfHLevelMaybe; just-inj; ¬nothing≡just; ¬just≡nothing)
  renaming (rec to matchMaybe)

module E where
\end{code}

Since we are working in Cubical Agda, it allows proofs in datatypes,
we can adapt the approach in Section~\ref{sec:dsl} to Cubical Agda.
This means we can add all the needed proofs (associativity, commutativity,
identity for both addition and multiplication) alongside
with the operators and constants into the language.

\subsection{Commutative semiring}

First, we will show that conatural numbers form a commutative semiring.

We mutually define expressions as an higher inductive type and head normal
expressions as a coinductive type.
\begin{AgdaAlign}
\begin{code}
  data Expr : Type
  record NExpr : Type
\end{code}
Head normal expressions are represented as a coinductive record from which we can extract the
predecessor.
\begin{code}
  record NExpr where
    coinductive
    field pred : Maybe Expr
\end{code}
\begin{code}[hide]
  open NExpr public

  infixl 6 _+_
  infixl 7 _×_
\end{code}
In \AgdaDatatype{Expr}, we include all of the commutative semiring equations, constants and
make its equalities proof irrelevant, that is it is a set.
\begin{code}
  data Expr where
    _+_        : Expr → Expr → Expr
    +-assoc    : ∀ x y z → (x + y) + z ≡ x + (y + z)
    +-comm     : ∀ x y → x + y ≡ y + x

    zero       : Expr
    +-idₗ      : ∀ x → zero + x ≡ x

    _×_        : Expr → Expr → Expr
    ×-assoc    : ∀ x y z → (x × y) × z ≡ x × (y × z)
    ×-comm     : ∀ x y → x × y ≡ y × x

    one        : Expr
    ×-idₗ      : ∀ x → one × x ≡ x

    ×-distₗ-+  : ∀ x y z → (x + y) × z ≡ x × z + y × z
    ×-annihₗ   : ∀ x → zero × x ≡ zero

    isSetExpr  : isSet Expr
\end{code}

We add a constructor to embed head normal expressions into expressions, this way
we can construct infinite expressions, as long as they are guarded.

\begin{code}
    embed : NExpr → Expr
\end{code}

We add equations to relate taking the predecessor on the head normal expression.

Note that here we use the destructor \AgdaField{pred} of \AgdaRecord{NExpr}.

\begin{code}
    embed-zero  :
      ∀ x → pred x ≡ nothing → embed x ≡ zero
    embed-suc   :
      ∀ x x' → pred x ≡ just x' → embed x ≡ one + x'
\end{code}

Finally, a constructor for transitivity because the general transitivity
function does not preserve guardedness.

\begin{code}
    trans : ∀ {x y z} → x ≡ y → y ≡ z → x ≡ z
\end{code}
\end{AgdaAlign}

We introduce an abbreviation to \AgdaFunction{suc}, which is not part of the language.

\begin{code}
  suc : Expr → Expr
  suc x = one + x
\end{code}
\begin{code}[hide]
  module ℕ∞Reasoning where
    infixl 6 _⟩+⟨_
    _⟩+⟨_ : ∀ {x x' y y'} → x ≡ x' → y ≡ y' → x + y ≡ x' + y'
    p ⟩+⟨ q = cong₂ _+_ p q

    +-idᵣ : ∀ x → x + zero ≡ x
    +-idᵣ x =
      x + zero ≡⟨ +-comm _ _ ⟩
      zero + x ≡⟨ +-idₗ _ ⟩
      x        ∎

    module _ {a x y z} (p : x + y ≡ z) where
      +-pullᵣ : a + x + y ≡ a + z
      +-pullᵣ =
        a + x + y   ≡⟨ +-assoc _ _ _ ⟩
        a + (x + y) ≡⟨ refl ⟩+⟨ p ⟩
        a + z       ∎

    module _ {a x y z} (p : x ≡ y + z) where
      +-pushᵣ : a + x ≡ a + y + z
      +-pushᵣ = sym (+-pullᵣ (sym p))

    module _ {a x} (p : zero ≡ x) where
      +-introₗ : a ≡ x + a
      +-introₗ =
        a        ≡⟨ sym (+-idₗ _) ⟩
        zero + a ≡⟨ p ⟩+⟨ refl ⟩
        x + a    ∎

      +-introᵣ : a ≡ a + x
      +-introᵣ =
        a        ≡⟨ sym (+-idᵣ _) ⟩
        a + zero ≡⟨ refl ⟩+⟨ p ⟩
        a + x    ∎

    module _ {a x} (p : x ≡ zero) where
      +-elimₗ : x + a ≡ a
      +-elimₗ = sym (+-introₗ (sym p))

      +-elimᵣ : a + x ≡ a
      +-elimᵣ = sym (+-introᵣ (sym p))

    module _ {a x y z w} (p : x + y ≡ z + w) where
      +-extendᵣ : a + x + y ≡ a + z + w
      +-extendᵣ =
        a + x + y   ≡⟨ +-assoc _ _ _ ⟩
        a + (x + y) ≡⟨ refl ⟩+⟨ p ⟩
        a + (z + w) ≡⟨ sym (+-assoc _ _ _) ⟩
        a + z + w   ∎

    +-sucₗ : ∀ x y → suc x + y ≡ suc (x + y)
    +-sucₗ x y = +-assoc _ _ _

    +-sucᵣ : ∀ x y → x + suc y ≡ suc (x + y)
    +-sucᵣ x y =
      x + suc y   ≡⟨ +-comm _ _ ⟩
      suc y + x   ≡⟨ +-sucₗ _ _ ⟩
      suc (y + x) ≡⟨ cong suc (+-comm _ _) ⟩
      suc (x + y) ∎

    infixl 7 _⟩×⟨_
    _⟩×⟨_ : ∀ {x x' y y'} → x ≡ x' → y ≡ y' → x × y ≡ x' × y'
    p ⟩×⟨ q = cong₂ _×_ p q

    ×-idᵣ : ∀ x → x × one ≡ x
    ×-idᵣ x =
      x × one ≡⟨ ×-comm _ _ ⟩
      one × x ≡⟨ ×-idₗ _ ⟩
      x       ∎

    module _ {a x y z} (p : x × y ≡ z) where
      ×-pullᵣ : a × x × y ≡ a × z
      ×-pullᵣ =
        a × x × y   ≡⟨ ×-assoc _ _ _ ⟩
        a × (x × y) ≡⟨ refl ⟩×⟨ p ⟩
        a × z       ∎

    module _ {a x y z} (p : x ≡ y × z) where
      ×-pushᵣ : a × x ≡ a × y × z
      ×-pushᵣ = sym (×-pullᵣ (sym p))

    module _ {a x} (p : one ≡ x) where
      ×-introᵣ : a ≡ a × x
      ×-introᵣ =
        a       ≡⟨ sym (×-idᵣ _) ⟩
        a × one ≡⟨ refl ⟩×⟨ p ⟩
        a × x   ∎

    module _ {a x} (p : x ≡ one) where
      ×-elimᵣ : a × x ≡ a
      ×-elimᵣ = sym (×-introᵣ (sym p))

    module _ {a x y z w} (p : x × y ≡ z × w) where
      ×-extendᵣ : a × x × y ≡ a × z × w
      ×-extendᵣ =
        a × x × y   ≡⟨ ×-assoc _ _ _ ⟩
        a × (x × y) ≡⟨ refl ⟩×⟨ p ⟩
        a × (z × w) ≡⟨ sym (×-assoc _ _ _) ⟩
        a × z × w   ∎

    ×-annihᵣ : ∀ x → x × zero ≡ zero
    ×-annihᵣ x =
      x × zero ≡⟨ ×-comm _ _ ⟩
      zero × x ≡⟨ ×-annihₗ _ ⟩
      zero     ∎

    ×-sucₗ : ∀ x y → suc x × y ≡ y + x × y
    ×-sucₗ x y =
      (one + x) × y   ≡⟨ ×-distₗ-+ _ _ _ ⟩
      one × y + x × y ≡⟨ ×-idₗ _ ⟩+⟨ refl ⟩
      y + x × y       ∎

    ×-sucᵣ : ∀ x y → x × suc y ≡ x + x × y
    ×-sucᵣ x y =
      x × suc y ≡⟨ ×-comm _ _ ⟩
      suc y × x ≡⟨ ×-sucₗ _ _ ⟩
      x + y × x ≡⟨ refl ⟩+⟨ ×-comm _ _ ⟩
      x + x × y ∎

    one-suc : one ≡ suc zero
    one-suc = sym (+-idᵣ _)

    unpred : Maybe Expr → Expr
    unpred nothing = zero
    unpred (just x') = suc x'

  open ℕ∞Reasoning
\end{code}

For convenience, we define an inductive predicate $\AgdaDatatype{IsPred}\ x'\ x$ which represents the
$\AgdaField{pred}\ x \mathrel{\AgdaFunction{≡}} x'$ equality but it can be pattern matched on.

\begin{code}
  data IsPred : Maybe Expr → Expr → Type where
    nothing  :         IsPred nothing    zero
    just     : ∀ x' →  IsPred (just x')  (suc x')
\end{code}
\begin{code}[hide]
  isPropIsPred-zero :
    ∀ {x' x} (p : nothing ≡ x') (q : zero ≡ x) r →
    PathP (λ i → IsPred (p i) (q i)) nothing r
  isPropIsPred-zero p q nothing =
    subst2 (λ e₁ e₂ → PathP (λ i → IsPred (e₁ i) (e₂ i)) nothing nothing)
      (isOfHLevelMaybe 0 isSetExpr _ _ refl p)
      (isSetExpr _ _ refl q)
      refl
  isPropIsPred-zero p q (just x') = ⊥.rec (¬nothing≡just p)

  isPropIsPred-suc :
    ∀ {x' x} x'′ (p : just x'′ ≡ x') (q : suc x'′ ≡ x) r →
    PathP (λ i → IsPred (p i) (q i)) (just x'′) r
  isPropIsPred-suc x'′ p q nothing = ⊥.rec (¬just≡nothing p)
  isPropIsPred-suc x'′ p q (just x') =
    subst2 (λ e₁ e₂ → PathP (λ i → IsPred (e₁ i) (e₂ i)) (just x'′) (just x'))
      (isOfHLevelMaybe 0 isSetExpr _ _ (cong just (just-inj _ _ p)) p)
      (isSetExpr _ _ (cong suc (just-inj _ _ p)) q)
      (cong IsPred.just (just-inj _ _ p))

  isPropIsPred : ∀ x' x → isProp (IsPred x' x)
  isPropIsPred _ _ nothing q = isPropIsPred-zero refl refl q
  isPropIsPred _ _ (just x') q = isPropIsPred-suc x' refl refl q
\end{code}

We want to define the predecessor function on expressions by induction.
We define the motive, so the termination checker doesn't get in our way.
If we do recursion by pattern matching over a higher inductive type, some
implicit arguments might get solved to an expression that is not reduced
and the termination checker complains. We want to avoid that.

\begin{code}
  record Pred (x : Expr) : Type where
    field
      pred    : Maybe Expr
      isPred  : IsPred pred x
\end{code}
\begin{code}[hide]
  open Pred
  unquoteDecl PredIsoΣ = declareRecordIsoΣ PredIsoΣ (quote Pred)

  Pred-path :
    ∀ {x y} {p : x ≡ y} {xᴾ yᴾ} →
    xᴾ .pred ≡ yᴾ .pred → PathP (λ i → Pred (p i)) xᴾ yᴾ
  Pred-path q i .pred = q i
  Pred-path {p} {xᴾ} {yᴾ} q i .isPred =
    isProp→PathP (λ i → isPropIsPred (q i) (p i)) (xᴾ .isPred) (yᴾ .isPred) i
\end{code}

We need \AgdaRecord{Pred} to be a set to be able to eliminate into it. Fortunately,
this fact is easily provable using the Cubical library's
\cite{The_Agda_Community_Cubical_Agda_Library_2025} functions.

\begin{code}
  isSetPred : ∀ x → isSet (Pred x)
\end{code}
\begin{code}[hide]
  isSetPred x =
    isOfHLevelRetractFromIso 2 PredIsoΣ
      (isSetΣ (isOfHLevelMaybe 0 isSetExpr) λ x' →
        isProp→isSet (isPropIsPred _ _))
\end{code}

We can define the functions of the motive each function corresponding to
the functions in \AgdaDatatype{Expr}.

If we know the predecessor of $x$ and $y$, then we can define the predecessor of $x + y$.

\begin{code}
  +-pred :
    Maybe Expr → Expr → Maybe Expr → Maybe Expr
  +-pred nothing    y y' = y'
  +-pred (just x')  y y' = just (x' + y)

  +-isPred :
    ∀ {x x' y y'} → IsPred x' x → IsPred y' y →
    IsPred (+-pred x' y y') (x + y)
  +-isPred {y} nothing    p = subst (IsPred _) (sym (+-idₗ _)) p
  +-isPred {y} (just x')  p =
    subst (IsPred _) (sym (+-assoc _ _ _)) (just (x' + y))

  infixl 6 _+ᴾ_
  _+ᴾ_ : ∀ {x y} → Pred x → Pred y → Pred (x + y)
  pred    (_+ᴾ_ {y}  xᴾ yᴾ) = +-pred (pred xᴾ) y (pred yᴾ)
  isPred  (_+ᴾ_      xᴾ yᴾ) = +-isPred (isPred xᴾ) (isPred yᴾ)
\end{code}

We can do the same for multiplication as well. Note that from this point on
we omit the $^P$ functions as those are going to be defined the previously
shown way every time.

\begin{code}
  ×-pred :
    Maybe Expr → Expr → Maybe Expr → Maybe Expr
  ×-pred nothing    y y'         = nothing
  ×-pred (just x')  y nothing    = nothing
  ×-pred (just x')  y (just y')  = just (y' + x' × y)
\end{code}
\begin{code}[hide]
  ×-isPred :
    ∀ {x x' y y'} →
    IsPred x' x → IsPred y' y → IsPred (×-pred x' y y') (x × y)
  ×-isPred nothing p = subst (IsPred _) (sym (×-annihₗ _)) nothing
  ×-isPred (just x') nothing = subst (IsPred _) (sym (×-annihᵣ _)) nothing
  ×-isPred {y} (just x') (just y') =
    subst (IsPred _)
      ( suc (y' + x' × y)  ≡⟨ sym (+-sucₗ _ _) ⟩
        suc y' + x' × y    ≡⟨⟩
        y + x' × y         ≡⟨ sym (×-sucₗ _ _) ⟩
        suc x' × y         ∎)
      (just (y' + x' × y))

  infixl 7 _×ᴾ_
  _×ᴾ_ : ∀ {x y} → Pred x → Pred y → Pred (x × y)
  _×ᴾ_ {y} xᴾ yᴾ .pred = ×-pred (xᴾ .pred) y (yᴾ .pred)
  (xᴾ ×ᴾ yᴾ) .isPred = ×-isPred (xᴾ .isPred) (yᴾ .isPred)

  +-assoc-pred :
    ∀ x' y y' z z' →
    +-pred (+-pred x' y y') z z' ≡ +-pred x' (y + z) (+-pred y' z z')
  +-assoc-pred nothing y y' z z' = refl
  +-assoc-pred (just x') y y' z z' = congS just (+-assoc _ _ _)

  +-assocᴾ :
    ∀ {x y z} xᴾ yᴾ zᴾ →
    PathP (λ i → Pred (+-assoc x y z i)) ((xᴾ +ᴾ yᴾ) +ᴾ zᴾ) (xᴾ +ᴾ (yᴾ +ᴾ zᴾ))
  +-assocᴾ {y} {z} xᴾ yᴾ zᴾ =
    Pred-path (+-assoc-pred (xᴾ .pred) y (yᴾ .pred) z (zᴾ .pred))
\end{code}

Now we are ready to prove the commutativity of addition.
Note that we don't even need to define the \AgdaField{isPred} component
because \AgdaRecord{IsPred} is a proposition. We also omit the uninteresting
parts of the stepping function for the proof of commutativity.

\begin{code}
  +-comm-pred :
    ∀ {x x' y y'} → IsPred x' x → IsPred y' y →
    +-pred x' y y' ≡ +-pred y' x x'
  +-comm-pred (just x') (just y') =
    congS just
      (  x' + suc y'    ≡⟨ +-sucᵣ _ _ ⟩
         suc (x' + y')  ≡⟨ cong suc (+-comm _ _) ⟩
         suc (y' + x')  ≡⟨ sym (+-sucᵣ _ _) ⟩
         y' + suc x'    ∎)
\end{code}
\begin{code}[hide]
  +-comm-pred nothing nothing = refl
  +-comm-pred nothing (just y') =
    congS just (sym (+-idᵣ _))
  +-comm-pred (just x') nothing =
    congS just (+-idᵣ _)

  +-commᴾ :
    ∀ {x y} xᴾ yᴾ → PathP (λ i → Pred (+-comm x y i)) (xᴾ +ᴾ yᴾ) (yᴾ +ᴾ xᴾ)
  +-commᴾ xᴾ yᴾ = Pred-path (+-comm-pred (xᴾ .isPred) (yᴾ .isPred))

  zeroᴾ : Pred zero
  zeroᴾ .pred = nothing
  zeroᴾ .isPred = nothing

  +-idₗᴾ : ∀ {x} xᴾ → PathP (λ i → Pred (+-idₗ x i)) (zeroᴾ +ᴾ xᴾ) xᴾ
  +-idₗᴾ xᴾ = Pred-path refl

  ×-assoc-pred :
    ∀ x' y y' z z' →
    ×-pred (×-pred x' y y') z z' ≡ ×-pred x' (y × z) (×-pred y' z z')
  ×-assoc-pred nothing y y' z z' = refl
  ×-assoc-pred (just x') y nothing z z' = refl
  ×-assoc-pred (just x') y (just y') z nothing = refl
  ×-assoc-pred (just x') y (just y') z (just z') =
    congS just
      ( z' + (y' + x' × y) × z     ≡⟨ +-pushᵣ (×-distₗ-+ _ _ _) ⟩
        z' + y' × z + x' × y × z   ≡⟨ refl ⟩+⟨ ×-assoc _ _ _ ⟩
        z' + y' × z + x' × (y × z) ∎)

  ×-assocᴾ : ∀ {x y z} xᴾ yᴾ zᴾ →
    PathP (λ i → Pred (×-assoc x y z i)) ((xᴾ ×ᴾ yᴾ) ×ᴾ zᴾ) (xᴾ ×ᴾ (yᴾ ×ᴾ zᴾ))
  ×-assocᴾ {x} {y} {z} xᴾ yᴾ zᴾ =
    Pred-path (×-assoc-pred (xᴾ .pred) y (yᴾ .pred) z (zᴾ .pred))

  ×-comm-pred :
    ∀ {x x' y y'} → IsPred x' x → IsPred y' y →
    ×-pred x' y y' ≡ ×-pred y' x x'
  ×-comm-pred nothing nothing = refl
  ×-comm-pred nothing (just y') = refl
  ×-comm-pred (just x') nothing = refl
  ×-comm-pred (just x') (just y') =
    congS just
      ( y' + x' × suc y'  ≡⟨ +-pushᵣ (×-sucᵣ _ _) ⟩
        y' + x' + x' × y' ≡⟨ +-comm _ _ ⟩+⟨ ×-comm _ _ ⟩
        x' + y' + y' × x' ≡⟨ +-pullᵣ (sym (×-sucᵣ _ _)) ⟩
        x' + y' × suc x' ∎)

  ×-commᴾ :
    ∀ {x y} xᴾ yᴾ → PathP (λ i → Pred (×-comm x y i)) (xᴾ ×ᴾ yᴾ) (yᴾ ×ᴾ xᴾ)
  ×-commᴾ xᴾ yᴾ = Pred-path (×-comm-pred (xᴾ .isPred) (yᴾ .isPred))

  oneᴾ : Pred one
  oneᴾ .pred = just zero
  oneᴾ .isPred = subst (IsPred _) (sym one-suc) (just zero)

  ×-idₗ-pred : ∀ x x' → ×-pred (just zero) x x' ≡ x'
  ×-idₗ-pred x nothing = refl
  ×-idₗ-pred x (just x') = congS just (+-elimᵣ (×-annihₗ _))

  ×-idₗᴾ : ∀ {x} xᴾ → PathP (λ i → Pred (×-idₗ x i)) (oneᴾ ×ᴾ xᴾ) xᴾ
  ×-idₗᴾ {x} xᴾ = Pred-path (×-idₗ-pred x (xᴾ .pred))

  ×-distₗ-+-pred :
    ∀ x' y y' z z' →
    ×-pred (+-pred x' y y') z z' ≡
    +-pred (×-pred x' z z') (y × z) (×-pred y' z z')
  ×-distₗ-+-pred nothing y y' z z' = refl
  ×-distₗ-+-pred (just x) y y' z (just z') =
    congS just (+-pushᵣ (×-distₗ-+ _ _ _))
  ×-distₗ-+-pred (just x) y nothing z nothing = refl
  ×-distₗ-+-pred (just x) y (just y') z nothing = refl

  ×-distₗ-+ᴾ :
    ∀ {x y z} xᴾ yᴾ zᴾ →
    PathP (λ i → Pred (×-distₗ-+ x y z i))
      ((xᴾ +ᴾ yᴾ) ×ᴾ zᴾ) (xᴾ ×ᴾ zᴾ +ᴾ yᴾ ×ᴾ zᴾ)
  ×-distₗ-+ᴾ {y} {z} xᴾ yᴾ zᴾ =
    Pred-path (×-distₗ-+-pred (xᴾ .pred) y (yᴾ .pred) z (zᴾ .pred))

  ×-annihₗᴾ : ∀ {x} xᴾ → PathP (λ i → Pred (×-annihₗ x i)) (zeroᴾ ×ᴾ xᴾ) zeroᴾ
  ×-annihₗᴾ xᴾ = Pred-path refl

  sucᴾ : ∀ {x} → Pred x → Pred (suc x)
  sucᴾ = oneᴾ +ᴾ_

  transᴾ :
    ∀ {x y z} {p : x ≡ y} {q : y ≡ z} {xᴾ yᴾ zᴾ} →
    PathP (λ i → Pred (p i)) xᴾ yᴾ → PathP (λ i → Pred (q i)) yᴾ zᴾ →
    PathP (λ i → Pred (trans p q i)) xᴾ zᴾ
  transᴾ pᴾ qᴾ = Pred-path ((λ i → pᴾ i .pred) ∙ (λ i → qᴾ i .pred))

  embed-isPred : ∀ x x' → x .pred ≡ x' → IsPred x' (embed x)
  embed-isPred x nothing p = subst (IsPred _) (sym (embed-zero x p)) nothing
  embed-isPred x (just x') p =
    subst (IsPred _) (sym (embed-suc x x' p)) (just x')

  embedᴾ : ∀ x → Pred (embed x)
  embedᴾ x .pred = x .pred
  embedᴾ x .isPred = embed-isPred x (x .pred) refl

  embed-zeroᴾ : ∀ x p → PathP (λ i → Pred (embed-zero x p i)) (embedᴾ x) zeroᴾ
  embed-zeroᴾ x p = Pred-path p

  embed-sucᴾ :
    ∀ {x'} x x'ᴾ p →
    PathP (λ i → Pred (embed-suc x x' p i)) (embedᴾ x) (sucᴾ x'ᴾ)
  embed-sucᴾ {x'} x x'ᴾ p = Pred-path
    ( x .pred          ≡⟨ p ⟩
      just x'          ≡⟨ congS just (sym (+-idₗ _)) ⟩
      just (zero + x') ∎)
\end{code}

We define the rest of the functions, formalisation is available in our repository.

Using the functions, we can recursively eliminate into \AgdaRecord{Pred}.

\begin{code}
  ⟦_⟧ᴾ : ∀ x → Pred x
\end{code}
\begin{code}[hide]
  ⟦ isSetExpr x y p q i j ⟧ᴾ =
    isOfHLevel→isOfHLevelDep 2 (λ x → isSetPred x)
      ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ (cong ⟦_⟧ᴾ p) (cong ⟦_⟧ᴾ q) (isSetExpr _ _ _ _) i j

  ⟦ x + y ⟧ᴾ = ⟦ x ⟧ᴾ +ᴾ ⟦ y ⟧ᴾ
  ⟦ +-assoc x y z i ⟧ᴾ = +-assocᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ ⟦ z ⟧ᴾ i
  ⟦ +-comm x y i ⟧ᴾ = +-commᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ i
  ⟦ zero ⟧ᴾ = zeroᴾ
  ⟦ +-idₗ x i ⟧ᴾ = +-idₗᴾ ⟦ x ⟧ᴾ i

  ⟦ x × y ⟧ᴾ = ⟦ x ⟧ᴾ ×ᴾ ⟦ y ⟧ᴾ
  ⟦ ×-assoc x y z i ⟧ᴾ = ×-assocᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ ⟦ z ⟧ᴾ i
  ⟦ ×-comm x y i ⟧ᴾ = ×-commᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ i
  ⟦ one ⟧ᴾ = oneᴾ
  ⟦ ×-idₗ x i ⟧ᴾ = ×-idₗᴾ ⟦ x ⟧ᴾ i
  ⟦ ×-distₗ-+ x y z i ⟧ᴾ = ×-distₗ-+ᴾ ⟦ x ⟧ᴾ ⟦ y ⟧ᴾ ⟦ z ⟧ᴾ i
  ⟦ ×-annihₗ x i ⟧ᴾ = ×-annihₗᴾ ⟦ x ⟧ᴾ i

  ⟦ trans p q i ⟧ᴾ = transᴾ (cong ⟦_⟧ᴾ p) (cong ⟦_⟧ᴾ q) i
  ⟦ embed x ⟧ᴾ = embedᴾ x
  ⟦ embed-zero x p i ⟧ᴾ = embed-zeroᴾ x p i
  ⟦ embed-suc x x' p i ⟧ᴾ = embed-sucᴾ x ⟦ x' ⟧ᴾ p i
\end{code}

Now we can extract our well-known \AgdaFunction{predᴱ} from previous sections.

\begin{code}
  predᴱ : Expr → Maybe Expr
  predᴱ x = pred ⟦ x ⟧ᴾ

  isPredᴱ : ∀ x → IsPred (predᴱ x) x
  isPredᴱ x = isPred ⟦ x ⟧ᴾ
\end{code}
\begin{code}[hide]
  pred-zero : predᴱ zero ≡ nothing
  pred-zero = refl

  pred-suc : ∀ x → predᴱ (suc x) ≡ just x
  pred-suc x = congS just (+-idₗ _)

  unpred-pred-pred : ∀ {x x'} → IsPred x' x → matchMaybe zero suc x' ≡ x
  unpred-pred-pred nothing = refl
  unpred-pred-pred (just x') = refl

  unpred-pred : ∀ x → matchMaybe zero suc (predᴱ x) ≡ x
  unpred-pred x = unpred-pred-pred (isPredᴱ x)

  interp : Expr → NExpr
  interp x .pred = predᴱ x

  interp-embed : ∀ x → interp (embed x) ≡ x
  interp-embed x i .pred = x .pred

  embed-interp : ∀ x → embed (interp x) ≡ x
  embed-interp-pred : ∀ {x x'} → IsPred x' x → embed (interp x) ≡ x

  embed-interp x = embed-interp-pred (isPredᴱ x)
  embed-interp-pred nothing = embed-zero (interp zero) refl
  embed-interp-pred (just x') =
    embed-suc (interp (suc x')) x' (congS just (+-idₗ _))
\end{code}


We can prove that \AgdaDatatype{Expr} is isomorphic to \AgdaRecord{NExpr}
beause we added \AgdaInductiveConstructor{embed-zero} and \AgdaInductiveConstructor{embed-suc}
to our language.
\begin{code}
  ExprIsoNExpr : Iso Expr NExpr
\end{code}
\begin{code}[hide]
  ExprIsoNExpr = iso interp embed interp-embed embed-interp

open E using (NExpr; Expr; pred; predᴱ)

record ℕ∞ : Type where
  coinductive
  field pred : Maybe ℕ∞

open ℕ∞ public
\end{code}
We can embed conatural numbers into expressions thanks to the
\AgdaInductiveConstructor{embed} constructor
\begin{code}
embed : ℕ∞ → Expr
\end{code}
\begin{code}[hide]
embedᴺ : ℕ∞ → NExpr
embed-pred : Maybe ℕ∞ → Maybe Expr

embed x = E.embed (embedᴺ x)
pred (embedᴺ x) = embed-pred (pred x)
embed-pred nothing = nothing
embed-pred (just x') = just (embed x')
\end{code}
Interpret expressions into conatural numbers using \AgdaFunction{predᴱ}
\begin{code}
interp : Expr → ℕ∞
interp-pred : Maybe Expr → Maybe ℕ∞

pred (interp x) = interp-pred (predᴱ x)
interp-pred nothing = nothing
interp-pred (just x') = just (interp x')
\end{code}

Stable

\begin{code}
interp-embed : ∀ x → interp (embed x) ≡ x
\end{code}
\begin{code}[hide]
interp-embed-pred : ∀ x' → interp-pred (embed-pred x') ≡ x'

pred (interp-embed x i) = interp-embed-pred (pred x) i
interp-embed-pred nothing = refl
interp-embed-pred (just x') = cong just (interp-embed x')
\end{code}

Complete

\begin{code}
embed-interp : ∀ x → embed (interp x) ≡ x
\end{code}
\begin{code}[hide]
embed-interpᴺ : ∀ x → embedᴺ (interp x) ≡ E.interp x
embed-interp-pred : ∀ x' → embed-pred (interp-pred x') ≡ x'

embed-interp x = E.trans (cong E.embed (embed-interpᴺ x)) (E.embed-interp x)
pred (embed-interpᴺ x i) = embed-interp-pred (predᴱ x) i
embed-interp-pred nothing = refl
embed-interp-pred (just x') = cong just (embed-interp x')
\end{code}
We get an isomorphism between \AgdaDatatype{Expr} and \AgdaRecord{ℕ∞}
\begin{code}
ExprIsoℕ∞ : Iso Expr ℕ∞
\end{code}
\begin{code}[hide]
ExprIsoℕ∞ = iso interp embed interp-embed embed-interp
\end{code}
Define a record with all the commutative semiring structure
\begin{AgdaAlign}
\begin{code}
record ℕ∞Str (A : Type) (pred : A → Maybe A) : Type where
\end{code}
\begin{code}[hide]
  infixl 6 _+_
  infixl 7 _×_
\end{code}
e.g.etc.
\begin{code}
  field
    isSetA   : isSet A
    _+_      : A → A → A
    +-assoc  : ∀ x y z → (x + y) + z ≡ x + (y + z)
    +-comm   : ∀ x y → x + y ≡ y + x
\end{code}
\begin{code}[hide]
    zero : A
    +-idₗ : ∀ x → zero + x ≡ x

    _×_ : A → A → A
    ×-assoc : ∀ x y z → (x × y) × z ≡ x × (y × z)
    ×-comm : ∀ x y → x × y ≡ y × x

    one : A
    ×-idₗ : ∀ x → one × x ≡ x

    ×-distₗ-+ : ∀ x y z → (x + y) × z ≡ x × z + y × z
    ×-annihₗ : ∀ x → zero × x ≡ zero

  suc : A → A
  suc = one +_
\end{code}
And we can also relate pred of ring operations
\begin{code}
  field
    pred-zero    : pred zero ≡ nothing
    pred-suc     : ∀ x → pred (one + x) ≡ just x
    unpred-pred  :
      ∀ x → matchMaybe zero (one +_) (pred x) ≡ x
\end{code}
\end{AgdaAlign}
We fill the record using expression
\begin{code}
ℕ∞StrExpr : ℕ∞Str Expr predᴱ
\end{code}
\begin{code}[hide]
ℕ∞StrExpr =
  record
    { isSetA = E.isSetExpr;
      Expr;
      pred-zero = E.pred-zero;
      pred-suc = E.pred-suc;
      unpred-pred = E.unpred-pred }
\end{code}
Using univalence we can transport over the isomorphism to get the record for
\AgdaRecord{ℕ∞}
\begin{code}
ℕ∞Strℕ∞ : ℕ∞Str ℕ∞ pred
ℕ∞Strℕ∞ =
  transport
    (cong₂ ℕ∞Str (isoToPath ExprIsoℕ∞) predᴱ≡pred)
    ℕ∞StrExpr
\end{code}
\begin{code}[hide]
  where
  subst-Maybe :
    ∀ x' → subst Maybe (isoToPath ExprIsoℕ∞) x' ≡ interp-pred x'
  subst-Maybe nothing = refl
  subst-Maybe (just x') = cong just (transportRefl _)
  predᴱ≡pred = ua→ λ x → toPathP (subst-Maybe _)

open ℕ∞Str ℕ∞Strℕ∞ renaming (isSetA to isSetℕ∞) public
\end{code}

\subsection{Exponentiation}
\input{latex/QuotientedExp}
